[2022-06-13 19:08:09] mrx-link.MRXLinkMagics.mrxlink_set_parameters() DEBUG: args: Namespace(base_url='http://localhost:8889/', cell='[{"name":"n_epochs","type":"int","value":"10"},{"name":"learning_rate","type":"float","value":"0.001"}]\n', cookie='_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20username-localhost-8889=2%7C1:0%7C10:1655114888%7C23:username-localhost-8889%7C44:Zjk5M2JlMTdiMDJkNDg4Mzg1MjY2ZmU3NTQ5NWYzMWM=%7C9f35010fe26ff182b313cb874205d2530c4c380d5e7ea8b36941da8382f68071', header='Accept-Encoding=gzip,%20deflate,%20br;Host=localhost:8889;%20Authorization=token%2080add5c51e8e1b74e94b4dc110540ec77ba79bfee95a32f9', no_reply=True)
[2022-06-13 19:08:09] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: args: Namespace(base_url='http://localhost:8889/', cell='{"nodes":[{"id":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","name":"Read data","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"#00DE62","comments":[]}},{"id":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","name":"Data loader","code":"def __pdc_data_loader__(  # type: ignore\\n    input_df: str,\\n    ratio: float,\\n    batch_size: int,\\n    batch_shuffle: bool,\\n    tv_shuffle: bool,\\n    drop_last: bool,\\n    target: list,  # type: ignore\\n):\\n    \\"\\"\\"read data from database\\"\\"\\"\\n    import random\\n    from typing import Any, Optional, Tuple\\n\\n    import pandas as pd\\n    import torch\\n    from torch.utils.data import DataLoader, Dataset\\n\\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\\n            super().__init__()\\n            self.data = torch.from_numpy(data.values)\\n            if target is not None:\\n                self.target = torch.from_numpy(target.values)\\n                if target.shape[-1] == 1:\\n                    self.target = torch.from_numpy(target.values.squeeze())\\n                else:\\n                    self.target = torch.from_numpy(target.values)\\n            else:\\n                self.target = target\\n\\n        def __len__(self) -> int:\\n            return len(self.data)\\n\\n        def __getitem__(self, idx: int) -> Any:\\n            if self.target is not None:\\n                return self.data[idx], self.target[idx]\\n            return self.data[idx]\\n\\n    # pylint: disable=missing-function-docstring\\n    def split(\\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\\n\\n        data_cnt = int(data.shape[0] * ratio)\\n\\n        indices = list(data.index)\\n        if shuffle:\\n            random.shuffle(indices)\\n\\n        if target is not None:\\n            return (\\n                (\\n                    pd.DataFrame(data, index=indices[:data_cnt]),\\n                    pd.DataFrame(target, index=indices[:data_cnt]),\\n                ),\\n                (\\n                    pd.DataFrame(data, index=indices[data_cnt:]),\\n                    pd.DataFrame(target, index=indices[data_cnt:]),\\n                ),\\n            )\\n        return (\\n            (\\n                pd.DataFrame(data, index=indices[:data_cnt]),\\n                None,\\n            ),\\n            (\\n                pd.DataFrame(data, index=indices[data_cnt:]),\\n                None,\\n            ),\\n        )\\n\\n    data: pd.DataFrame = input_df\\n    train_loader, valid_loader = None, None\\n    if target:\\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\\n        target_df = pd.DataFrame(data, columns=target)\\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0], target=train[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n    else:\\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n\\n    return train_loader, valid_loader\\n\\ntrain, valid = __pdc_data_loader__(\\n    input_df=df,\\n    ratio=0.8,\\n    batch_size=4,\\n    batch_shuffle=True,\\n    tv_shuffle=True,\\n    drop_last=True,\\n    target=[\'class\'],\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"62535059-9784-42d0-9799-29d5c99f3472","name":"Modeling","code":"from torch import nn\\nfrom torch.nn import functional as F  \\n\\nclass Model(nn.Module):\\n    def __init__(self, input_dim):\\n        super(Model, self).__init__()\\n        self.layer1 = nn.Linear(input_dim, 50)\\n        self.layer2 = nn.Linear(50, 50)\\n        self.layer3 = nn.Linear(50, 3)\\n    def forward(self, x):\\n        x = F.relu(self.layer1(x))\\n        x = F.relu(self.layer2(x))\\n        x = F.softmax(self.layer3(x), dim=1)\\n        return x\\n    \\nmodel = Model(4).double()","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","name":"Training","code":"def __pdc_trainer__(  # type: ignore # noqa: C901\\n    is_classification: int,\\n    train_loader,  # DataLoader\\n    valid_loader,  # DataLoader\\n    train_metric_members,  # List[str]\\n    valid_metric_members,  # List[str]\\n    monitoring: str,\\n    early_stopping_mode: str,\\n    model,  # nn.Module\\n    loss_impl,  # nn.Module\\n    optimizer_impl,  # nn.optim\\n    learning_rate: float,\\n    n_epochs: int,\\n):\\n    from collections import defaultdict\\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\\n\\n    import pytorch_lightning as pl\\n    import torch\\n    import torchmetrics\\n    from livelossplot import PlotLosses\\n    from pytorch_lightning.callbacks import EarlyStopping\\n    from pytorch_lightning.loggers import LightningLoggerBase\\n    from pytorch_lightning.utilities.distributed import rank_zero_only\\n    from torch import nn\\n    from torch.optim import Optimizer\\n\\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\\n        \\"\\"\\"Canvas Trainer Logger\\"\\"\\"\\n\\n        def __init__(self) -> None:\\n            super().__init__()\\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\\n            self.live_metric = PlotLosses()\\n\\n        @property\\n        def experiment(self) -> None:\\n            pass\\n\\n        @property\\n        def name(self) -> str:\\n            return \\"CanvasTrainerLogger\\"\\n\\n        @property\\n        def version(self) -> str:\\n            return \\"mvp\\"\\n\\n        @rank_zero_only\\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\\n            pass\\n\\n        @rank_zero_only\\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\\n            del metrics[\\"epoch\\"]\\n\\n            if not metrics.keys():\\n                return\\n\\n            is_valid = list(metrics.keys())[-1][:4] == \\"val_\\"\\n\\n            if is_valid:\\n                self.metric_history[\\"val\\"].append(metrics)\\n            else:\\n                self.metric_history[\\"train\\"].append(metrics)\\n                self.live_metric.update({**self.metric_history[\\"train\\"][-1], **self.metric_history[\\"val\\"][-1]})\\n                self.live_metric.send()\\n\\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\\n        def __init__(  # pylint: disable=too-many-arguments\\n            self,\\n            model: nn.Module,\\n            loss_impl: nn.Module,\\n            optimizer_impl: Optimizer,\\n            learning_rate: float,\\n            metric_members: Dict[str, Any],\\n            is_classification: int,\\n        ) -> None:\\n            super().__init__()\\n            self.model = model\\n\\n            self.loss_func = loss_impl()\\n            self.optimizer_impl = optimizer_impl\\n            self.learning_rate = learning_rate\\n\\n            self.metric_members = metric_members\\n\\n            for mode in [\\"train\\", \\"val\\"]:\\n                auroc_metric_attr = (mode + \\"_\\" if mode != \\"train\\" else \\"\\") + \\"auroc\\"\\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get(\\"AUROC\\"))\\n\\n            self._is_classification = is_classification\\n\\n        # pylint: disable=invalid-name\\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\\n            \\"\\"\\"calculate log metric with metric members\\"\\"\\"\\n            metric_members, prefix = None, \\"\\"\\n            if is_valid:\\n                metric_members = self.metric_members[\\"val\\"]\\n                prefix += \\"val_\\"\\n            else:\\n                metric_members = self.metric_members[\\"train\\"]\\n\\n            for metric_member_str, metric_impl in metric_members.items():\\n                if metric_member_str == \\"AUROC\\":\\n                    getattr(self, prefix + \\"auroc\\")(y_hat.detach(), y.detach())\\n                    try:\\n                        self.log(\\n                            prefix + metric_member_str, getattr(self, prefix + \\"auroc\\"), on_step=False, on_epoch=True\\n                        )\\n                    except ValueError():  # type: ignore\\n                        pass\\n\\n                else:\\n                    metric = metric_impl(y_hat, y)\\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\\n\\n        # pylint: disable=arguments-differ\\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=False)\\n\\n        # pylint: disable=arguments-differ\\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=True)\\n\\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\\n            x, y = batch  # pylint: disable=invalid-name\\n            if self._is_classification:\\n                y = y.long()  # pylint: disable=invalid-name\\n            y_hat = self.model(x)\\n\\n            loss = self.loss_func(y_hat, y)\\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\\n            return loss\\n\\n        def configure_optimizers(self) -> Optimizer:\\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\\n\\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\\n        \\"\\"\\"load metric implementation on torch.nn or torchmetrics with their names\\"\\"\\"\\n        metric_impls = {}\\n        for member_str in members:\\n            if member_str == \\"AUROC\\":\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\\n                    num_classes=num_classes, compute_on_step=False\\n                )\\n\\n            elif member_str in [\\"CrossEntropyLoss\\", \\"MSELoss\\", \\"L1Loss\\"]:\\n                metric_impls[member_str] = getattr(nn, member_str)()\\n\\n            elif member_str in [\\"Accuracy\\", \\"AUROC\\", \\"R2Score\\"]:\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\\n        return metric_impls\\n\\n    # trainer main\\n    n_classes = None\\n    if is_classification:\\n        labels = torch.cat([y for _, y in valid_loader])\\n        if len(labels.unique()) > 2:\\n            n_classes = len(labels.unique())\\n\\n    metric_members = dict(\\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\\n    )\\n\\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\\n    early_stopping_callback = EarlyStopping(monitor=\\"val_\\" + monitoring, mode=early_stopping_mode)\\n    lit = LitModule(\\n        model=model,\\n        loss_impl=loss_impl,\\n        optimizer_impl=optimizer_impl,\\n        learning_rate=learning_rate,\\n        metric_members=metric_members,\\n        is_classification=is_classification,\\n    )\\n    trainer = pl.Trainer(\\n        max_epochs=n_epochs,\\n        logger=canvas_trainer_logger,\\n        callbacks=[early_stopping_callback],\\n        checkpoint_callback=False,\\n    )\\n    trainer.fit(lit, train_loader, valid_loader)\\n    return (canvas_trainer_logger.metric_history, model, model)\\n\\nimport torch\\nc, b, a = __pdc_trainer__(\\n    is_classification=1,\\n    train_loader=train,\\n    valid_loader=valid,\\n    train_metric_members=[\'CrossEntropyLoss\'],\\n    valid_metric_members=[\'CrossEntropyLoss\'],\\n    monitoring=\'CrossEntropyLoss\',\\n    early_stopping_mode=\'min\',\\n    model=model,\\n    loss_impl=torch.nn.CrossEntropyLoss,\\n    optimizer_impl=torch.optim.Adam,\\n    learning_rate=learning_rate,\\n    n_epochs=n_epochs,\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","name":"new component","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"inherit","comments":[]}},{"id":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07","name":"new component_2","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}}],"edges":[{"parent":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","child":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642"},{"parent":"62535059-9784-42d0-9799-29d5c99f3472","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","child":"84484d20-2bd6-472d-91a1-a9c10d1bb17d"},{"parent":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","child":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07"}]}\n', cookie='_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20username-localhost-8889=2%7C1:0%7C10:1655114889%7C23:username-localhost-8889%7C44:ZDhlMTAyNjNkNWVjNGI1NGI3NDA0MmFjYTZiMGEzMzU=%7C19e132e498bdd5942a2e14e95845221fde40b5dba15b33e9b33cc033ab7c806c', header='Accept-Encoding=gzip,%20deflate,%20br;Host=localhost:8889;%20Authorization=token%2080add5c51e8e1b74e94b4dc110540ec77ba79bfee95a32f9')
[2022-06-13 19:08:09] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: graph: {'nodes': [{'id': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'name': 'Read data', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': '#00DE62', 'comments': []}}, {'id': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'name': 'Data loader', 'code': 'def __pdc_data_loader__(  # type: ignore\n    input_df: str,\n    ratio: float,\n    batch_size: int,\n    batch_shuffle: bool,\n    tv_shuffle: bool,\n    drop_last: bool,\n    target: list,  # type: ignore\n):\n    """read data from database"""\n    import random\n    from typing import Any, Optional, Tuple\n\n    import pandas as pd\n    import torch\n    from torch.utils.data import DataLoader, Dataset\n\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\n            super().__init__()\n            self.data = torch.from_numpy(data.values)\n            if target is not None:\n                self.target = torch.from_numpy(target.values)\n                if target.shape[-1] == 1:\n                    self.target = torch.from_numpy(target.values.squeeze())\n                else:\n                    self.target = torch.from_numpy(target.values)\n            else:\n                self.target = target\n\n        def __len__(self) -> int:\n            return len(self.data)\n\n        def __getitem__(self, idx: int) -> Any:\n            if self.target is not None:\n                return self.data[idx], self.target[idx]\n            return self.data[idx]\n\n    # pylint: disable=missing-function-docstring\n    def split(\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\n\n        data_cnt = int(data.shape[0] * ratio)\n\n        indices = list(data.index)\n        if shuffle:\n            random.shuffle(indices)\n\n        if target is not None:\n            return (\n                (\n                    pd.DataFrame(data, index=indices[:data_cnt]),\n                    pd.DataFrame(target, index=indices[:data_cnt]),\n                ),\n                (\n                    pd.DataFrame(data, index=indices[data_cnt:]),\n                    pd.DataFrame(target, index=indices[data_cnt:]),\n                ),\n            )\n        return (\n            (\n                pd.DataFrame(data, index=indices[:data_cnt]),\n                None,\n            ),\n            (\n                pd.DataFrame(data, index=indices[data_cnt:]),\n                None,\n            ),\n        )\n\n    data: pd.DataFrame = input_df\n    train_loader, valid_loader = None, None\n    if target:\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\n        target_df = pd.DataFrame(data, columns=target)\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0], target=train[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n    else:\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n\n    return train_loader, valid_loader\n\ntrain, valid = __pdc_data_loader__(\n    input_df=df,\n    ratio=0.8,\n    batch_size=4,\n    batch_shuffle=True,\n    tv_shuffle=True,\n    drop_last=True,\n    target=[\'class\'],\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '62535059-9784-42d0-9799-29d5c99f3472', 'name': 'Modeling', 'code': 'from torch import nn\nfrom torch.nn import functional as F  \n\nclass Model(nn.Module):\n    def __init__(self, input_dim):\n        super(Model, self).__init__()\n        self.layer1 = nn.Linear(input_dim, 50)\n        self.layer2 = nn.Linear(50, 50)\n        self.layer3 = nn.Linear(50, 3)\n    def forward(self, x):\n        x = F.relu(self.layer1(x))\n        x = F.relu(self.layer2(x))\n        x = F.softmax(self.layer3(x), dim=1)\n        return x\n    \nmodel = Model(4).double()', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'name': 'Training', 'code': 'def __pdc_trainer__(  # type: ignore # noqa: C901\n    is_classification: int,\n    train_loader,  # DataLoader\n    valid_loader,  # DataLoader\n    train_metric_members,  # List[str]\n    valid_metric_members,  # List[str]\n    monitoring: str,\n    early_stopping_mode: str,\n    model,  # nn.Module\n    loss_impl,  # nn.Module\n    optimizer_impl,  # nn.optim\n    learning_rate: float,\n    n_epochs: int,\n):\n    from collections import defaultdict\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\n\n    import pytorch_lightning as pl\n    import torch\n    import torchmetrics\n    from livelossplot import PlotLosses\n    from pytorch_lightning.callbacks import EarlyStopping\n    from pytorch_lightning.loggers import LightningLoggerBase\n    from pytorch_lightning.utilities.distributed import rank_zero_only\n    from torch import nn\n    from torch.optim import Optimizer\n\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\n        """Canvas Trainer Logger"""\n\n        def __init__(self) -> None:\n            super().__init__()\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\n            self.live_metric = PlotLosses()\n\n        @property\n        def experiment(self) -> None:\n            pass\n\n        @property\n        def name(self) -> str:\n            return "CanvasTrainerLogger"\n\n        @property\n        def version(self) -> str:\n            return "mvp"\n\n        @rank_zero_only\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\n            pass\n\n        @rank_zero_only\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\n            del metrics["epoch"]\n\n            if not metrics.keys():\n                return\n\n            is_valid = list(metrics.keys())[-1][:4] == "val_"\n\n            if is_valid:\n                self.metric_history["val"].append(metrics)\n            else:\n                self.metric_history["train"].append(metrics)\n                self.live_metric.update({**self.metric_history["train"][-1], **self.metric_history["val"][-1]})\n                self.live_metric.send()\n\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\n        def __init__(  # pylint: disable=too-many-arguments\n            self,\n            model: nn.Module,\n            loss_impl: nn.Module,\n            optimizer_impl: Optimizer,\n            learning_rate: float,\n            metric_members: Dict[str, Any],\n            is_classification: int,\n        ) -> None:\n            super().__init__()\n            self.model = model\n\n            self.loss_func = loss_impl()\n            self.optimizer_impl = optimizer_impl\n            self.learning_rate = learning_rate\n\n            self.metric_members = metric_members\n\n            for mode in ["train", "val"]:\n                auroc_metric_attr = (mode + "_" if mode != "train" else "") + "auroc"\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get("AUROC"))\n\n            self._is_classification = is_classification\n\n        # pylint: disable=invalid-name\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\n            """calculate log metric with metric members"""\n            metric_members, prefix = None, ""\n            if is_valid:\n                metric_members = self.metric_members["val"]\n                prefix += "val_"\n            else:\n                metric_members = self.metric_members["train"]\n\n            for metric_member_str, metric_impl in metric_members.items():\n                if metric_member_str == "AUROC":\n                    getattr(self, prefix + "auroc")(y_hat.detach(), y.detach())\n                    try:\n                        self.log(\n                            prefix + metric_member_str, getattr(self, prefix + "auroc"), on_step=False, on_epoch=True\n                        )\n                    except ValueError():  # type: ignore\n                        pass\n\n                else:\n                    metric = metric_impl(y_hat, y)\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\n\n        # pylint: disable=arguments-differ\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=False)\n\n        # pylint: disable=arguments-differ\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=True)\n\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\n            x, y = batch  # pylint: disable=invalid-name\n            if self._is_classification:\n                y = y.long()  # pylint: disable=invalid-name\n            y_hat = self.model(x)\n\n            loss = self.loss_func(y_hat, y)\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\n            return loss\n\n        def configure_optimizers(self) -> Optimizer:\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\n\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\n        """load metric implementation on torch.nn or torchmetrics with their names"""\n        metric_impls = {}\n        for member_str in members:\n            if member_str == "AUROC":\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\n                    num_classes=num_classes, compute_on_step=False\n                )\n\n            elif member_str in ["CrossEntropyLoss", "MSELoss", "L1Loss"]:\n                metric_impls[member_str] = getattr(nn, member_str)()\n\n            elif member_str in ["Accuracy", "AUROC", "R2Score"]:\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\n        return metric_impls\n\n    # trainer main\n    n_classes = None\n    if is_classification:\n        labels = torch.cat([y for _, y in valid_loader])\n        if len(labels.unique()) > 2:\n            n_classes = len(labels.unique())\n\n    metric_members = dict(\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\n    )\n\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\n    early_stopping_callback = EarlyStopping(monitor="val_" + monitoring, mode=early_stopping_mode)\n    lit = LitModule(\n        model=model,\n        loss_impl=loss_impl,\n        optimizer_impl=optimizer_impl,\n        learning_rate=learning_rate,\n        metric_members=metric_members,\n        is_classification=is_classification,\n    )\n    trainer = pl.Trainer(\n        max_epochs=n_epochs,\n        logger=canvas_trainer_logger,\n        callbacks=[early_stopping_callback],\n        checkpoint_callback=False,\n    )\n    trainer.fit(lit, train_loader, valid_loader)\n    return (canvas_trainer_logger.metric_history, model, model)\n\nimport torch\nc, b, a = __pdc_trainer__(\n    is_classification=1,\n    train_loader=train,\n    valid_loader=valid,\n    train_metric_members=[\'CrossEntropyLoss\'],\n    valid_metric_members=[\'CrossEntropyLoss\'],\n    monitoring=\'CrossEntropyLoss\',\n    early_stopping_mode=\'min\',\n    model=model,\n    loss_impl=torch.nn.CrossEntropyLoss,\n    optimizer_impl=torch.optim.Adam,\n    learning_rate=learning_rate,\n    n_epochs=n_epochs,\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'name': 'new component', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'inherit', 'comments': []}}, {'id': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07', 'name': 'new component_2', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}], 'edges': [{'parent': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'child': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642'}, {'parent': '62535059-9784-42d0-9799-29d5c99f3472', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'child': '84484d20-2bd6-472d-91a1-a9c10d1bb17d'}, {'parent': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'child': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07'}]}
[2022-06-13 19:13:32] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: args: Namespace(base_url='http://localhost:8889/', cell='{"nodes":[{"id":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","name":"Read data","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf12","metadata":{"componentType":"CodeCell","headerColor":"#00DE62","comments":[]}},{"id":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","name":"Data loader","code":"def __pdc_data_loader__(  # type: ignore\\n    input_df: str,\\n    ratio: float,\\n    batch_size: int,\\n    batch_shuffle: bool,\\n    tv_shuffle: bool,\\n    drop_last: bool,\\n    target: list,  # type: ignore\\n):\\n    \\"\\"\\"read data from database\\"\\"\\"\\n    import random\\n    from typing import Any, Optional, Tuple\\n\\n    import pandas as pd\\n    import torch\\n    from torch.utils.data import DataLoader, Dataset\\n\\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\\n            super().__init__()\\n            self.data = torch.from_numpy(data.values)\\n            if target is not None:\\n                self.target = torch.from_numpy(target.values)\\n                if target.shape[-1] == 1:\\n                    self.target = torch.from_numpy(target.values.squeeze())\\n                else:\\n                    self.target = torch.from_numpy(target.values)\\n            else:\\n                self.target = target\\n\\n        def __len__(self) -> int:\\n            return len(self.data)\\n\\n        def __getitem__(self, idx: int) -> Any:\\n            if self.target is not None:\\n                return self.data[idx], self.target[idx]\\n            return self.data[idx]\\n\\n    # pylint: disable=missing-function-docstring\\n    def split(\\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\\n\\n        data_cnt = int(data.shape[0] * ratio)\\n\\n        indices = list(data.index)\\n        if shuffle:\\n            random.shuffle(indices)\\n\\n        if target is not None:\\n            return (\\n                (\\n                    pd.DataFrame(data, index=indices[:data_cnt]),\\n                    pd.DataFrame(target, index=indices[:data_cnt]),\\n                ),\\n                (\\n                    pd.DataFrame(data, index=indices[data_cnt:]),\\n                    pd.DataFrame(target, index=indices[data_cnt:]),\\n                ),\\n            )\\n        return (\\n            (\\n                pd.DataFrame(data, index=indices[:data_cnt]),\\n                None,\\n            ),\\n            (\\n                pd.DataFrame(data, index=indices[data_cnt:]),\\n                None,\\n            ),\\n        )\\n\\n    data: pd.DataFrame = input_df\\n    train_loader, valid_loader = None, None\\n    if target:\\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\\n        target_df = pd.DataFrame(data, columns=target)\\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0], target=train[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n    else:\\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n\\n    return train_loader, valid_loader\\n\\ntrain, valid = __pdc_data_loader__(\\n    input_df=df,\\n    ratio=0.8,\\n    batch_size=4,\\n    batch_shuffle=True,\\n    tv_shuffle=True,\\n    drop_last=True,\\n    target=[\'class\'],\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"62535059-9784-42d0-9799-29d5c99f3472","name":"Modeling","code":"from torch import nn\\nfrom torch.nn import functional as F  \\n\\nclass Model(nn.Module):\\n    def __init__(self, input_dim):\\n        super(Model, self).__init__()\\n        self.layer1 = nn.Linear(input_dim, 50)\\n        self.layer2 = nn.Linear(50, 50)\\n        self.layer3 = nn.Linear(50, 3)\\n    def forward(self, x):\\n        x = F.relu(self.layer1(x))\\n        x = F.relu(self.layer2(x))\\n        x = F.softmax(self.layer3(x), dim=1)\\n        return x\\n    \\nmodel = Model(4).double()","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","name":"Training","code":"def __pdc_trainer__(  # type: ignore # noqa: C901\\n    is_classification: int,\\n    train_loader,  # DataLoader\\n    valid_loader,  # DataLoader\\n    train_metric_members,  # List[str]\\n    valid_metric_members,  # List[str]\\n    monitoring: str,\\n    early_stopping_mode: str,\\n    model,  # nn.Module\\n    loss_impl,  # nn.Module\\n    optimizer_impl,  # nn.optim\\n    learning_rate: float,\\n    n_epochs: int,\\n):\\n    from collections import defaultdict\\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\\n\\n    import pytorch_lightning as pl\\n    import torch\\n    import torchmetrics\\n    from livelossplot import PlotLosses\\n    from pytorch_lightning.callbacks import EarlyStopping\\n    from pytorch_lightning.loggers import LightningLoggerBase\\n    from pytorch_lightning.utilities.distributed import rank_zero_only\\n    from torch import nn\\n    from torch.optim import Optimizer\\n\\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\\n        \\"\\"\\"Canvas Trainer Logger\\"\\"\\"\\n\\n        def __init__(self) -> None:\\n            super().__init__()\\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\\n            self.live_metric = PlotLosses()\\n\\n        @property\\n        def experiment(self) -> None:\\n            pass\\n\\n        @property\\n        def name(self) -> str:\\n            return \\"CanvasTrainerLogger\\"\\n\\n        @property\\n        def version(self) -> str:\\n            return \\"mvp\\"\\n\\n        @rank_zero_only\\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\\n            pass\\n\\n        @rank_zero_only\\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\\n            del metrics[\\"epoch\\"]\\n\\n            if not metrics.keys():\\n                return\\n\\n            is_valid = list(metrics.keys())[-1][:4] == \\"val_\\"\\n\\n            if is_valid:\\n                self.metric_history[\\"val\\"].append(metrics)\\n            else:\\n                self.metric_history[\\"train\\"].append(metrics)\\n                self.live_metric.update({**self.metric_history[\\"train\\"][-1], **self.metric_history[\\"val\\"][-1]})\\n                self.live_metric.send()\\n\\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\\n        def __init__(  # pylint: disable=too-many-arguments\\n            self,\\n            model: nn.Module,\\n            loss_impl: nn.Module,\\n            optimizer_impl: Optimizer,\\n            learning_rate: float,\\n            metric_members: Dict[str, Any],\\n            is_classification: int,\\n        ) -> None:\\n            super().__init__()\\n            self.model = model\\n\\n            self.loss_func = loss_impl()\\n            self.optimizer_impl = optimizer_impl\\n            self.learning_rate = learning_rate\\n\\n            self.metric_members = metric_members\\n\\n            for mode in [\\"train\\", \\"val\\"]:\\n                auroc_metric_attr = (mode + \\"_\\" if mode != \\"train\\" else \\"\\") + \\"auroc\\"\\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get(\\"AUROC\\"))\\n\\n            self._is_classification = is_classification\\n\\n        # pylint: disable=invalid-name\\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\\n            \\"\\"\\"calculate log metric with metric members\\"\\"\\"\\n            metric_members, prefix = None, \\"\\"\\n            if is_valid:\\n                metric_members = self.metric_members[\\"val\\"]\\n                prefix += \\"val_\\"\\n            else:\\n                metric_members = self.metric_members[\\"train\\"]\\n\\n            for metric_member_str, metric_impl in metric_members.items():\\n                if metric_member_str == \\"AUROC\\":\\n                    getattr(self, prefix + \\"auroc\\")(y_hat.detach(), y.detach())\\n                    try:\\n                        self.log(\\n                            prefix + metric_member_str, getattr(self, prefix + \\"auroc\\"), on_step=False, on_epoch=True\\n                        )\\n                    except ValueError():  # type: ignore\\n                        pass\\n\\n                else:\\n                    metric = metric_impl(y_hat, y)\\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\\n\\n        # pylint: disable=arguments-differ\\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=False)\\n\\n        # pylint: disable=arguments-differ\\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=True)\\n\\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\\n            x, y = batch  # pylint: disable=invalid-name\\n            if self._is_classification:\\n                y = y.long()  # pylint: disable=invalid-name\\n            y_hat = self.model(x)\\n\\n            loss = self.loss_func(y_hat, y)\\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\\n            return loss\\n\\n        def configure_optimizers(self) -> Optimizer:\\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\\n\\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\\n        \\"\\"\\"load metric implementation on torch.nn or torchmetrics with their names\\"\\"\\"\\n        metric_impls = {}\\n        for member_str in members:\\n            if member_str == \\"AUROC\\":\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\\n                    num_classes=num_classes, compute_on_step=False\\n                )\\n\\n            elif member_str in [\\"CrossEntropyLoss\\", \\"MSELoss\\", \\"L1Loss\\"]:\\n                metric_impls[member_str] = getattr(nn, member_str)()\\n\\n            elif member_str in [\\"Accuracy\\", \\"AUROC\\", \\"R2Score\\"]:\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\\n        return metric_impls\\n\\n    # trainer main\\n    n_classes = None\\n    if is_classification:\\n        labels = torch.cat([y for _, y in valid_loader])\\n        if len(labels.unique()) > 2:\\n            n_classes = len(labels.unique())\\n\\n    metric_members = dict(\\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\\n    )\\n\\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\\n    early_stopping_callback = EarlyStopping(monitor=\\"val_\\" + monitoring, mode=early_stopping_mode)\\n    lit = LitModule(\\n        model=model,\\n        loss_impl=loss_impl,\\n        optimizer_impl=optimizer_impl,\\n        learning_rate=learning_rate,\\n        metric_members=metric_members,\\n        is_classification=is_classification,\\n    )\\n    trainer = pl.Trainer(\\n        max_epochs=n_epochs,\\n        logger=canvas_trainer_logger,\\n        callbacks=[early_stopping_callback],\\n        checkpoint_callback=False,\\n    )\\n    trainer.fit(lit, train_loader, valid_loader)\\n    return (canvas_trainer_logger.metric_history, model, model)\\n\\nimport torch\\nc, b, a = __pdc_trainer__(\\n    is_classification=1,\\n    train_loader=train,\\n    valid_loader=valid,\\n    train_metric_members=[\'CrossEntropyLoss\'],\\n    valid_metric_members=[\'CrossEntropyLoss\'],\\n    monitoring=\'CrossEntropyLoss\',\\n    early_stopping_mode=\'min\',\\n    model=model,\\n    loss_impl=torch.nn.CrossEntropyLoss,\\n    optimizer_impl=torch.optim.Adam,\\n    learning_rate=learning_rate,\\n    n_epochs=n_epochs,\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","name":"new component","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"inherit","comments":[]}},{"id":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07","name":"new component_2","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}}],"edges":[{"parent":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","child":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642"},{"parent":"62535059-9784-42d0-9799-29d5c99f3472","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","child":"84484d20-2bd6-472d-91a1-a9c10d1bb17d"},{"parent":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","child":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07"}]}\n', cookie='_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20username-localhost-8889=2%7C1:0%7C10:1655115209%7C23:username-localhost-8889%7C44:MmEzMzkzNGY4MTY0NDg2MzgxN2EzZWRiYmQyM2JkNTY=%7C5f41ea559b0f54a0ac8a87c6f3868d8aee54586de6c071b8b82cd52b07556a87', header='Accept-Encoding=gzip,%20deflate,%20br;Host=localhost:8889;%20Authorization=token%2080add5c51e8e1b74e94b4dc110540ec77ba79bfee95a32f9')
[2022-06-13 19:13:32] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: graph: {'nodes': [{'id': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'name': 'Read data', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf12', 'metadata': {'componentType': 'CodeCell', 'headerColor': '#00DE62', 'comments': []}}, {'id': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'name': 'Data loader', 'code': 'def __pdc_data_loader__(  # type: ignore\n    input_df: str,\n    ratio: float,\n    batch_size: int,\n    batch_shuffle: bool,\n    tv_shuffle: bool,\n    drop_last: bool,\n    target: list,  # type: ignore\n):\n    """read data from database"""\n    import random\n    from typing import Any, Optional, Tuple\n\n    import pandas as pd\n    import torch\n    from torch.utils.data import DataLoader, Dataset\n\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\n            super().__init__()\n            self.data = torch.from_numpy(data.values)\n            if target is not None:\n                self.target = torch.from_numpy(target.values)\n                if target.shape[-1] == 1:\n                    self.target = torch.from_numpy(target.values.squeeze())\n                else:\n                    self.target = torch.from_numpy(target.values)\n            else:\n                self.target = target\n\n        def __len__(self) -> int:\n            return len(self.data)\n\n        def __getitem__(self, idx: int) -> Any:\n            if self.target is not None:\n                return self.data[idx], self.target[idx]\n            return self.data[idx]\n\n    # pylint: disable=missing-function-docstring\n    def split(\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\n\n        data_cnt = int(data.shape[0] * ratio)\n\n        indices = list(data.index)\n        if shuffle:\n            random.shuffle(indices)\n\n        if target is not None:\n            return (\n                (\n                    pd.DataFrame(data, index=indices[:data_cnt]),\n                    pd.DataFrame(target, index=indices[:data_cnt]),\n                ),\n                (\n                    pd.DataFrame(data, index=indices[data_cnt:]),\n                    pd.DataFrame(target, index=indices[data_cnt:]),\n                ),\n            )\n        return (\n            (\n                pd.DataFrame(data, index=indices[:data_cnt]),\n                None,\n            ),\n            (\n                pd.DataFrame(data, index=indices[data_cnt:]),\n                None,\n            ),\n        )\n\n    data: pd.DataFrame = input_df\n    train_loader, valid_loader = None, None\n    if target:\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\n        target_df = pd.DataFrame(data, columns=target)\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0], target=train[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n    else:\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n\n    return train_loader, valid_loader\n\ntrain, valid = __pdc_data_loader__(\n    input_df=df,\n    ratio=0.8,\n    batch_size=4,\n    batch_shuffle=True,\n    tv_shuffle=True,\n    drop_last=True,\n    target=[\'class\'],\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '62535059-9784-42d0-9799-29d5c99f3472', 'name': 'Modeling', 'code': 'from torch import nn\nfrom torch.nn import functional as F  \n\nclass Model(nn.Module):\n    def __init__(self, input_dim):\n        super(Model, self).__init__()\n        self.layer1 = nn.Linear(input_dim, 50)\n        self.layer2 = nn.Linear(50, 50)\n        self.layer3 = nn.Linear(50, 3)\n    def forward(self, x):\n        x = F.relu(self.layer1(x))\n        x = F.relu(self.layer2(x))\n        x = F.softmax(self.layer3(x), dim=1)\n        return x\n    \nmodel = Model(4).double()', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'name': 'Training', 'code': 'def __pdc_trainer__(  # type: ignore # noqa: C901\n    is_classification: int,\n    train_loader,  # DataLoader\n    valid_loader,  # DataLoader\n    train_metric_members,  # List[str]\n    valid_metric_members,  # List[str]\n    monitoring: str,\n    early_stopping_mode: str,\n    model,  # nn.Module\n    loss_impl,  # nn.Module\n    optimizer_impl,  # nn.optim\n    learning_rate: float,\n    n_epochs: int,\n):\n    from collections import defaultdict\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\n\n    import pytorch_lightning as pl\n    import torch\n    import torchmetrics\n    from livelossplot import PlotLosses\n    from pytorch_lightning.callbacks import EarlyStopping\n    from pytorch_lightning.loggers import LightningLoggerBase\n    from pytorch_lightning.utilities.distributed import rank_zero_only\n    from torch import nn\n    from torch.optim import Optimizer\n\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\n        """Canvas Trainer Logger"""\n\n        def __init__(self) -> None:\n            super().__init__()\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\n            self.live_metric = PlotLosses()\n\n        @property\n        def experiment(self) -> None:\n            pass\n\n        @property\n        def name(self) -> str:\n            return "CanvasTrainerLogger"\n\n        @property\n        def version(self) -> str:\n            return "mvp"\n\n        @rank_zero_only\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\n            pass\n\n        @rank_zero_only\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\n            del metrics["epoch"]\n\n            if not metrics.keys():\n                return\n\n            is_valid = list(metrics.keys())[-1][:4] == "val_"\n\n            if is_valid:\n                self.metric_history["val"].append(metrics)\n            else:\n                self.metric_history["train"].append(metrics)\n                self.live_metric.update({**self.metric_history["train"][-1], **self.metric_history["val"][-1]})\n                self.live_metric.send()\n\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\n        def __init__(  # pylint: disable=too-many-arguments\n            self,\n            model: nn.Module,\n            loss_impl: nn.Module,\n            optimizer_impl: Optimizer,\n            learning_rate: float,\n            metric_members: Dict[str, Any],\n            is_classification: int,\n        ) -> None:\n            super().__init__()\n            self.model = model\n\n            self.loss_func = loss_impl()\n            self.optimizer_impl = optimizer_impl\n            self.learning_rate = learning_rate\n\n            self.metric_members = metric_members\n\n            for mode in ["train", "val"]:\n                auroc_metric_attr = (mode + "_" if mode != "train" else "") + "auroc"\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get("AUROC"))\n\n            self._is_classification = is_classification\n\n        # pylint: disable=invalid-name\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\n            """calculate log metric with metric members"""\n            metric_members, prefix = None, ""\n            if is_valid:\n                metric_members = self.metric_members["val"]\n                prefix += "val_"\n            else:\n                metric_members = self.metric_members["train"]\n\n            for metric_member_str, metric_impl in metric_members.items():\n                if metric_member_str == "AUROC":\n                    getattr(self, prefix + "auroc")(y_hat.detach(), y.detach())\n                    try:\n                        self.log(\n                            prefix + metric_member_str, getattr(self, prefix + "auroc"), on_step=False, on_epoch=True\n                        )\n                    except ValueError():  # type: ignore\n                        pass\n\n                else:\n                    metric = metric_impl(y_hat, y)\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\n\n        # pylint: disable=arguments-differ\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=False)\n\n        # pylint: disable=arguments-differ\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=True)\n\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\n            x, y = batch  # pylint: disable=invalid-name\n            if self._is_classification:\n                y = y.long()  # pylint: disable=invalid-name\n            y_hat = self.model(x)\n\n            loss = self.loss_func(y_hat, y)\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\n            return loss\n\n        def configure_optimizers(self) -> Optimizer:\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\n\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\n        """load metric implementation on torch.nn or torchmetrics with their names"""\n        metric_impls = {}\n        for member_str in members:\n            if member_str == "AUROC":\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\n                    num_classes=num_classes, compute_on_step=False\n                )\n\n            elif member_str in ["CrossEntropyLoss", "MSELoss", "L1Loss"]:\n                metric_impls[member_str] = getattr(nn, member_str)()\n\n            elif member_str in ["Accuracy", "AUROC", "R2Score"]:\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\n        return metric_impls\n\n    # trainer main\n    n_classes = None\n    if is_classification:\n        labels = torch.cat([y for _, y in valid_loader])\n        if len(labels.unique()) > 2:\n            n_classes = len(labels.unique())\n\n    metric_members = dict(\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\n    )\n\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\n    early_stopping_callback = EarlyStopping(monitor="val_" + monitoring, mode=early_stopping_mode)\n    lit = LitModule(\n        model=model,\n        loss_impl=loss_impl,\n        optimizer_impl=optimizer_impl,\n        learning_rate=learning_rate,\n        metric_members=metric_members,\n        is_classification=is_classification,\n    )\n    trainer = pl.Trainer(\n        max_epochs=n_epochs,\n        logger=canvas_trainer_logger,\n        callbacks=[early_stopping_callback],\n        checkpoint_callback=False,\n    )\n    trainer.fit(lit, train_loader, valid_loader)\n    return (canvas_trainer_logger.metric_history, model, model)\n\nimport torch\nc, b, a = __pdc_trainer__(\n    is_classification=1,\n    train_loader=train,\n    valid_loader=valid,\n    train_metric_members=[\'CrossEntropyLoss\'],\n    valid_metric_members=[\'CrossEntropyLoss\'],\n    monitoring=\'CrossEntropyLoss\',\n    early_stopping_mode=\'min\',\n    model=model,\n    loss_impl=torch.nn.CrossEntropyLoss,\n    optimizer_impl=torch.optim.Adam,\n    learning_rate=learning_rate,\n    n_epochs=n_epochs,\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'name': 'new component', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'inherit', 'comments': []}}, {'id': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07', 'name': 'new component_2', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}], 'edges': [{'parent': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'child': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642'}, {'parent': '62535059-9784-42d0-9799-29d5c99f3472', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'child': '84484d20-2bd6-472d-91a1-a9c10d1bb17d'}, {'parent': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'child': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07'}]}
[2022-06-13 19:13:33] mrx-link.MRXLinkDag.add_node() DEBUG: <Read data (ab2d95a2-220f-4f7d-8c1a-ef03b514587e)>.component_type: CodeCell -> CodeCell
[2022-06-13 19:13:33] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: args: Namespace(base_url='http://localhost:8889/', cell='{"nodes":[{"id":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","name":"Read data","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf123","metadata":{"componentType":"CodeCell","headerColor":"#00DE62","comments":[]}},{"id":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","name":"Data loader","code":"def __pdc_data_loader__(  # type: ignore\\n    input_df: str,\\n    ratio: float,\\n    batch_size: int,\\n    batch_shuffle: bool,\\n    tv_shuffle: bool,\\n    drop_last: bool,\\n    target: list,  # type: ignore\\n):\\n    \\"\\"\\"read data from database\\"\\"\\"\\n    import random\\n    from typing import Any, Optional, Tuple\\n\\n    import pandas as pd\\n    import torch\\n    from torch.utils.data import DataLoader, Dataset\\n\\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\\n            super().__init__()\\n            self.data = torch.from_numpy(data.values)\\n            if target is not None:\\n                self.target = torch.from_numpy(target.values)\\n                if target.shape[-1] == 1:\\n                    self.target = torch.from_numpy(target.values.squeeze())\\n                else:\\n                    self.target = torch.from_numpy(target.values)\\n            else:\\n                self.target = target\\n\\n        def __len__(self) -> int:\\n            return len(self.data)\\n\\n        def __getitem__(self, idx: int) -> Any:\\n            if self.target is not None:\\n                return self.data[idx], self.target[idx]\\n            return self.data[idx]\\n\\n    # pylint: disable=missing-function-docstring\\n    def split(\\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\\n\\n        data_cnt = int(data.shape[0] * ratio)\\n\\n        indices = list(data.index)\\n        if shuffle:\\n            random.shuffle(indices)\\n\\n        if target is not None:\\n            return (\\n                (\\n                    pd.DataFrame(data, index=indices[:data_cnt]),\\n                    pd.DataFrame(target, index=indices[:data_cnt]),\\n                ),\\n                (\\n                    pd.DataFrame(data, index=indices[data_cnt:]),\\n                    pd.DataFrame(target, index=indices[data_cnt:]),\\n                ),\\n            )\\n        return (\\n            (\\n                pd.DataFrame(data, index=indices[:data_cnt]),\\n                None,\\n            ),\\n            (\\n                pd.DataFrame(data, index=indices[data_cnt:]),\\n                None,\\n            ),\\n        )\\n\\n    data: pd.DataFrame = input_df\\n    train_loader, valid_loader = None, None\\n    if target:\\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\\n        target_df = pd.DataFrame(data, columns=target)\\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0], target=train[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n    else:\\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n\\n    return train_loader, valid_loader\\n\\ntrain, valid = __pdc_data_loader__(\\n    input_df=df,\\n    ratio=0.8,\\n    batch_size=4,\\n    batch_shuffle=True,\\n    tv_shuffle=True,\\n    drop_last=True,\\n    target=[\'class\'],\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"62535059-9784-42d0-9799-29d5c99f3472","name":"Modeling","code":"from torch import nn\\nfrom torch.nn import functional as F  \\n\\nclass Model(nn.Module):\\n    def __init__(self, input_dim):\\n        super(Model, self).__init__()\\n        self.layer1 = nn.Linear(input_dim, 50)\\n        self.layer2 = nn.Linear(50, 50)\\n        self.layer3 = nn.Linear(50, 3)\\n    def forward(self, x):\\n        x = F.relu(self.layer1(x))\\n        x = F.relu(self.layer2(x))\\n        x = F.softmax(self.layer3(x), dim=1)\\n        return x\\n    \\nmodel = Model(4).double()","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","name":"Training","code":"def __pdc_trainer__(  # type: ignore # noqa: C901\\n    is_classification: int,\\n    train_loader,  # DataLoader\\n    valid_loader,  # DataLoader\\n    train_metric_members,  # List[str]\\n    valid_metric_members,  # List[str]\\n    monitoring: str,\\n    early_stopping_mode: str,\\n    model,  # nn.Module\\n    loss_impl,  # nn.Module\\n    optimizer_impl,  # nn.optim\\n    learning_rate: float,\\n    n_epochs: int,\\n):\\n    from collections import defaultdict\\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\\n\\n    import pytorch_lightning as pl\\n    import torch\\n    import torchmetrics\\n    from livelossplot import PlotLosses\\n    from pytorch_lightning.callbacks import EarlyStopping\\n    from pytorch_lightning.loggers import LightningLoggerBase\\n    from pytorch_lightning.utilities.distributed import rank_zero_only\\n    from torch import nn\\n    from torch.optim import Optimizer\\n\\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\\n        \\"\\"\\"Canvas Trainer Logger\\"\\"\\"\\n\\n        def __init__(self) -> None:\\n            super().__init__()\\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\\n            self.live_metric = PlotLosses()\\n\\n        @property\\n        def experiment(self) -> None:\\n            pass\\n\\n        @property\\n        def name(self) -> str:\\n            return \\"CanvasTrainerLogger\\"\\n\\n        @property\\n        def version(self) -> str:\\n            return \\"mvp\\"\\n\\n        @rank_zero_only\\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\\n            pass\\n\\n        @rank_zero_only\\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\\n            del metrics[\\"epoch\\"]\\n\\n            if not metrics.keys():\\n                return\\n\\n            is_valid = list(metrics.keys())[-1][:4] == \\"val_\\"\\n\\n            if is_valid:\\n                self.metric_history[\\"val\\"].append(metrics)\\n            else:\\n                self.metric_history[\\"train\\"].append(metrics)\\n                self.live_metric.update({**self.metric_history[\\"train\\"][-1], **self.metric_history[\\"val\\"][-1]})\\n                self.live_metric.send()\\n\\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\\n        def __init__(  # pylint: disable=too-many-arguments\\n            self,\\n            model: nn.Module,\\n            loss_impl: nn.Module,\\n            optimizer_impl: Optimizer,\\n            learning_rate: float,\\n            metric_members: Dict[str, Any],\\n            is_classification: int,\\n        ) -> None:\\n            super().__init__()\\n            self.model = model\\n\\n            self.loss_func = loss_impl()\\n            self.optimizer_impl = optimizer_impl\\n            self.learning_rate = learning_rate\\n\\n            self.metric_members = metric_members\\n\\n            for mode in [\\"train\\", \\"val\\"]:\\n                auroc_metric_attr = (mode + \\"_\\" if mode != \\"train\\" else \\"\\") + \\"auroc\\"\\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get(\\"AUROC\\"))\\n\\n            self._is_classification = is_classification\\n\\n        # pylint: disable=invalid-name\\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\\n            \\"\\"\\"calculate log metric with metric members\\"\\"\\"\\n            metric_members, prefix = None, \\"\\"\\n            if is_valid:\\n                metric_members = self.metric_members[\\"val\\"]\\n                prefix += \\"val_\\"\\n            else:\\n                metric_members = self.metric_members[\\"train\\"]\\n\\n            for metric_member_str, metric_impl in metric_members.items():\\n                if metric_member_str == \\"AUROC\\":\\n                    getattr(self, prefix + \\"auroc\\")(y_hat.detach(), y.detach())\\n                    try:\\n                        self.log(\\n                            prefix + metric_member_str, getattr(self, prefix + \\"auroc\\"), on_step=False, on_epoch=True\\n                        )\\n                    except ValueError():  # type: ignore\\n                        pass\\n\\n                else:\\n                    metric = metric_impl(y_hat, y)\\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\\n\\n        # pylint: disable=arguments-differ\\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=False)\\n\\n        # pylint: disable=arguments-differ\\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=True)\\n\\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\\n            x, y = batch  # pylint: disable=invalid-name\\n            if self._is_classification:\\n                y = y.long()  # pylint: disable=invalid-name\\n            y_hat = self.model(x)\\n\\n            loss = self.loss_func(y_hat, y)\\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\\n            return loss\\n\\n        def configure_optimizers(self) -> Optimizer:\\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\\n\\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\\n        \\"\\"\\"load metric implementation on torch.nn or torchmetrics with their names\\"\\"\\"\\n        metric_impls = {}\\n        for member_str in members:\\n            if member_str == \\"AUROC\\":\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\\n                    num_classes=num_classes, compute_on_step=False\\n                )\\n\\n            elif member_str in [\\"CrossEntropyLoss\\", \\"MSELoss\\", \\"L1Loss\\"]:\\n                metric_impls[member_str] = getattr(nn, member_str)()\\n\\n            elif member_str in [\\"Accuracy\\", \\"AUROC\\", \\"R2Score\\"]:\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\\n        return metric_impls\\n\\n    # trainer main\\n    n_classes = None\\n    if is_classification:\\n        labels = torch.cat([y for _, y in valid_loader])\\n        if len(labels.unique()) > 2:\\n            n_classes = len(labels.unique())\\n\\n    metric_members = dict(\\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\\n    )\\n\\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\\n    early_stopping_callback = EarlyStopping(monitor=\\"val_\\" + monitoring, mode=early_stopping_mode)\\n    lit = LitModule(\\n        model=model,\\n        loss_impl=loss_impl,\\n        optimizer_impl=optimizer_impl,\\n        learning_rate=learning_rate,\\n        metric_members=metric_members,\\n        is_classification=is_classification,\\n    )\\n    trainer = pl.Trainer(\\n        max_epochs=n_epochs,\\n        logger=canvas_trainer_logger,\\n        callbacks=[early_stopping_callback],\\n        checkpoint_callback=False,\\n    )\\n    trainer.fit(lit, train_loader, valid_loader)\\n    return (canvas_trainer_logger.metric_history, model, model)\\n\\nimport torch\\nc, b, a = __pdc_trainer__(\\n    is_classification=1,\\n    train_loader=train,\\n    valid_loader=valid,\\n    train_metric_members=[\'CrossEntropyLoss\'],\\n    valid_metric_members=[\'CrossEntropyLoss\'],\\n    monitoring=\'CrossEntropyLoss\',\\n    early_stopping_mode=\'min\',\\n    model=model,\\n    loss_impl=torch.nn.CrossEntropyLoss,\\n    optimizer_impl=torch.optim.Adam,\\n    learning_rate=learning_rate,\\n    n_epochs=n_epochs,\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","name":"new component","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"inherit","comments":[]}},{"id":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07","name":"new component_2","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}}],"edges":[{"parent":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","child":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642"},{"parent":"62535059-9784-42d0-9799-29d5c99f3472","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","child":"84484d20-2bd6-472d-91a1-a9c10d1bb17d"},{"parent":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","child":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07"}]}\n', cookie='_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20username-localhost-8889=2%7C1:0%7C10:1655115212%7C23:username-localhost-8889%7C44:MjAzOGY1YTQ3NTA3NGI3MWE1Y2U5NGI2NTIyZDM5OTk=%7Cbfc44b26e490395f7205f0f38c1f4de130b49c5debf5a9d4508b081ca70baf23', header='Accept-Encoding=gzip,%20deflate,%20br;Host=localhost:8889;%20Authorization=token%2080add5c51e8e1b74e94b4dc110540ec77ba79bfee95a32f9')
[2022-06-13 19:13:33] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: graph: {'nodes': [{'id': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'name': 'Read data', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf123', 'metadata': {'componentType': 'CodeCell', 'headerColor': '#00DE62', 'comments': []}}, {'id': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'name': 'Data loader', 'code': 'def __pdc_data_loader__(  # type: ignore\n    input_df: str,\n    ratio: float,\n    batch_size: int,\n    batch_shuffle: bool,\n    tv_shuffle: bool,\n    drop_last: bool,\n    target: list,  # type: ignore\n):\n    """read data from database"""\n    import random\n    from typing import Any, Optional, Tuple\n\n    import pandas as pd\n    import torch\n    from torch.utils.data import DataLoader, Dataset\n\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\n            super().__init__()\n            self.data = torch.from_numpy(data.values)\n            if target is not None:\n                self.target = torch.from_numpy(target.values)\n                if target.shape[-1] == 1:\n                    self.target = torch.from_numpy(target.values.squeeze())\n                else:\n                    self.target = torch.from_numpy(target.values)\n            else:\n                self.target = target\n\n        def __len__(self) -> int:\n            return len(self.data)\n\n        def __getitem__(self, idx: int) -> Any:\n            if self.target is not None:\n                return self.data[idx], self.target[idx]\n            return self.data[idx]\n\n    # pylint: disable=missing-function-docstring\n    def split(\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\n\n        data_cnt = int(data.shape[0] * ratio)\n\n        indices = list(data.index)\n        if shuffle:\n            random.shuffle(indices)\n\n        if target is not None:\n            return (\n                (\n                    pd.DataFrame(data, index=indices[:data_cnt]),\n                    pd.DataFrame(target, index=indices[:data_cnt]),\n                ),\n                (\n                    pd.DataFrame(data, index=indices[data_cnt:]),\n                    pd.DataFrame(target, index=indices[data_cnt:]),\n                ),\n            )\n        return (\n            (\n                pd.DataFrame(data, index=indices[:data_cnt]),\n                None,\n            ),\n            (\n                pd.DataFrame(data, index=indices[data_cnt:]),\n                None,\n            ),\n        )\n\n    data: pd.DataFrame = input_df\n    train_loader, valid_loader = None, None\n    if target:\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\n        target_df = pd.DataFrame(data, columns=target)\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0], target=train[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n    else:\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n\n    return train_loader, valid_loader\n\ntrain, valid = __pdc_data_loader__(\n    input_df=df,\n    ratio=0.8,\n    batch_size=4,\n    batch_shuffle=True,\n    tv_shuffle=True,\n    drop_last=True,\n    target=[\'class\'],\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '62535059-9784-42d0-9799-29d5c99f3472', 'name': 'Modeling', 'code': 'from torch import nn\nfrom torch.nn import functional as F  \n\nclass Model(nn.Module):\n    def __init__(self, input_dim):\n        super(Model, self).__init__()\n        self.layer1 = nn.Linear(input_dim, 50)\n        self.layer2 = nn.Linear(50, 50)\n        self.layer3 = nn.Linear(50, 3)\n    def forward(self, x):\n        x = F.relu(self.layer1(x))\n        x = F.relu(self.layer2(x))\n        x = F.softmax(self.layer3(x), dim=1)\n        return x\n    \nmodel = Model(4).double()', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'name': 'Training', 'code': 'def __pdc_trainer__(  # type: ignore # noqa: C901\n    is_classification: int,\n    train_loader,  # DataLoader\n    valid_loader,  # DataLoader\n    train_metric_members,  # List[str]\n    valid_metric_members,  # List[str]\n    monitoring: str,\n    early_stopping_mode: str,\n    model,  # nn.Module\n    loss_impl,  # nn.Module\n    optimizer_impl,  # nn.optim\n    learning_rate: float,\n    n_epochs: int,\n):\n    from collections import defaultdict\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\n\n    import pytorch_lightning as pl\n    import torch\n    import torchmetrics\n    from livelossplot import PlotLosses\n    from pytorch_lightning.callbacks import EarlyStopping\n    from pytorch_lightning.loggers import LightningLoggerBase\n    from pytorch_lightning.utilities.distributed import rank_zero_only\n    from torch import nn\n    from torch.optim import Optimizer\n\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\n        """Canvas Trainer Logger"""\n\n        def __init__(self) -> None:\n            super().__init__()\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\n            self.live_metric = PlotLosses()\n\n        @property\n        def experiment(self) -> None:\n            pass\n\n        @property\n        def name(self) -> str:\n            return "CanvasTrainerLogger"\n\n        @property\n        def version(self) -> str:\n            return "mvp"\n\n        @rank_zero_only\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\n            pass\n\n        @rank_zero_only\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\n            del metrics["epoch"]\n\n            if not metrics.keys():\n                return\n\n            is_valid = list(metrics.keys())[-1][:4] == "val_"\n\n            if is_valid:\n                self.metric_history["val"].append(metrics)\n            else:\n                self.metric_history["train"].append(metrics)\n                self.live_metric.update({**self.metric_history["train"][-1], **self.metric_history["val"][-1]})\n                self.live_metric.send()\n\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\n        def __init__(  # pylint: disable=too-many-arguments\n            self,\n            model: nn.Module,\n            loss_impl: nn.Module,\n            optimizer_impl: Optimizer,\n            learning_rate: float,\n            metric_members: Dict[str, Any],\n            is_classification: int,\n        ) -> None:\n            super().__init__()\n            self.model = model\n\n            self.loss_func = loss_impl()\n            self.optimizer_impl = optimizer_impl\n            self.learning_rate = learning_rate\n\n            self.metric_members = metric_members\n\n            for mode in ["train", "val"]:\n                auroc_metric_attr = (mode + "_" if mode != "train" else "") + "auroc"\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get("AUROC"))\n\n            self._is_classification = is_classification\n\n        # pylint: disable=invalid-name\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\n            """calculate log metric with metric members"""\n            metric_members, prefix = None, ""\n            if is_valid:\n                metric_members = self.metric_members["val"]\n                prefix += "val_"\n            else:\n                metric_members = self.metric_members["train"]\n\n            for metric_member_str, metric_impl in metric_members.items():\n                if metric_member_str == "AUROC":\n                    getattr(self, prefix + "auroc")(y_hat.detach(), y.detach())\n                    try:\n                        self.log(\n                            prefix + metric_member_str, getattr(self, prefix + "auroc"), on_step=False, on_epoch=True\n                        )\n                    except ValueError():  # type: ignore\n                        pass\n\n                else:\n                    metric = metric_impl(y_hat, y)\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\n\n        # pylint: disable=arguments-differ\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=False)\n\n        # pylint: disable=arguments-differ\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=True)\n\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\n            x, y = batch  # pylint: disable=invalid-name\n            if self._is_classification:\n                y = y.long()  # pylint: disable=invalid-name\n            y_hat = self.model(x)\n\n            loss = self.loss_func(y_hat, y)\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\n            return loss\n\n        def configure_optimizers(self) -> Optimizer:\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\n\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\n        """load metric implementation on torch.nn or torchmetrics with their names"""\n        metric_impls = {}\n        for member_str in members:\n            if member_str == "AUROC":\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\n                    num_classes=num_classes, compute_on_step=False\n                )\n\n            elif member_str in ["CrossEntropyLoss", "MSELoss", "L1Loss"]:\n                metric_impls[member_str] = getattr(nn, member_str)()\n\n            elif member_str in ["Accuracy", "AUROC", "R2Score"]:\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\n        return metric_impls\n\n    # trainer main\n    n_classes = None\n    if is_classification:\n        labels = torch.cat([y for _, y in valid_loader])\n        if len(labels.unique()) > 2:\n            n_classes = len(labels.unique())\n\n    metric_members = dict(\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\n    )\n\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\n    early_stopping_callback = EarlyStopping(monitor="val_" + monitoring, mode=early_stopping_mode)\n    lit = LitModule(\n        model=model,\n        loss_impl=loss_impl,\n        optimizer_impl=optimizer_impl,\n        learning_rate=learning_rate,\n        metric_members=metric_members,\n        is_classification=is_classification,\n    )\n    trainer = pl.Trainer(\n        max_epochs=n_epochs,\n        logger=canvas_trainer_logger,\n        callbacks=[early_stopping_callback],\n        checkpoint_callback=False,\n    )\n    trainer.fit(lit, train_loader, valid_loader)\n    return (canvas_trainer_logger.metric_history, model, model)\n\nimport torch\nc, b, a = __pdc_trainer__(\n    is_classification=1,\n    train_loader=train,\n    valid_loader=valid,\n    train_metric_members=[\'CrossEntropyLoss\'],\n    valid_metric_members=[\'CrossEntropyLoss\'],\n    monitoring=\'CrossEntropyLoss\',\n    early_stopping_mode=\'min\',\n    model=model,\n    loss_impl=torch.nn.CrossEntropyLoss,\n    optimizer_impl=torch.optim.Adam,\n    learning_rate=learning_rate,\n    n_epochs=n_epochs,\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'name': 'new component', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'inherit', 'comments': []}}, {'id': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07', 'name': 'new component_2', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}], 'edges': [{'parent': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'child': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642'}, {'parent': '62535059-9784-42d0-9799-29d5c99f3472', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'child': '84484d20-2bd6-472d-91a1-a9c10d1bb17d'}, {'parent': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'child': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07'}]}
[2022-06-13 19:13:33] mrx-link.MRXLinkDag.add_node() DEBUG: <Read data (ab2d95a2-220f-4f7d-8c1a-ef03b514587e)>.component_type: CodeCell -> CodeCell
[2022-06-13 19:13:36] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: args: Namespace(base_url='http://localhost:8889/', cell='{"nodes":[{"id":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","name":"Read data","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf123","metadata":{"componentType":"CodeCell","headerColor":"#00DE62","comments":[]}},{"id":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","name":"Data loader","code":"def __pdc_data_loader__(  # type: ignore\\n    input_df: str,\\n    ratio: float,\\n    batch_size: int,\\n    batch_shuffle: bool,\\n    tv_shuffle: bool,\\n    drop_last: bool,\\n    target: list,  # type: ignore\\n):\\n    \\"\\"\\"read data from database\\"\\"\\"\\n    import random\\n    from typing import Any, Optional, Tuple\\n\\n    import pandas as pd\\n    import torch\\n    from torch.utils.data import DataLoader, Dataset\\n\\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\\n            super().__init__()\\n            self.data = torch.from_numpy(data.values)\\n            if target is not None:\\n                self.target = torch.from_numpy(target.values)\\n                if target.shape[-1] == 1:\\n                    self.target = torch.from_numpy(target.values.squeeze())\\n                else:\\n                    self.target = torch.from_numpy(target.values)\\n            else:\\n                self.target = target\\n\\n        def __len__(self) -> int:\\n            return len(self.data)\\n\\n        def __getitem__(self, idx: int) -> Any:\\n            if self.target is not None:\\n                return self.data[idx], self.target[idx]\\n            return self.data[idx]\\n\\n    # pylint: disable=missing-function-docstring\\n    def split(\\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\\n\\n        data_cnt = int(data.shape[0] * ratio)\\n\\n        indices = list(data.index)\\n        if shuffle:\\n            random.shuffle(indices)\\n\\n        if target is not None:\\n            return (\\n                (\\n                    pd.DataFrame(data, index=indices[:data_cnt]),\\n                    pd.DataFrame(target, index=indices[:data_cnt]),\\n                ),\\n                (\\n                    pd.DataFrame(data, index=indices[data_cnt:]),\\n                    pd.DataFrame(target, index=indices[data_cnt:]),\\n                ),\\n            )\\n        return (\\n            (\\n                pd.DataFrame(data, index=indices[:data_cnt]),\\n                None,\\n            ),\\n            (\\n                pd.DataFrame(data, index=indices[data_cnt:]),\\n                None,\\n            ),\\n        )\\n\\n    data: pd.DataFrame = input_df\\n    train_loader, valid_loader = None, None\\n    if target:\\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\\n        target_df = pd.DataFrame(data, columns=target)\\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0], target=train[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n    else:\\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\\n        if train[0].shape[0] > 0:\\n            train_loader = DataLoader(\\n                dataset=SampleDataset(data=train[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n        if valid[0].shape[0] > 0:\\n            valid_loader = DataLoader(\\n                dataset=SampleDataset(data=valid[0]),\\n                batch_size=batch_size,\\n                shuffle=batch_shuffle,\\n                drop_last=drop_last,\\n            )\\n\\n    return train_loader, valid_loader\\n\\ntrain, valid = __pdc_data_loader__(\\n    input_df=df,\\n    ratio=0.8,\\n    batch_size=4,\\n    batch_shuffle=True,\\n    tv_shuffle=True,\\n    drop_last=True,\\n    target=[\'class\'],\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"62535059-9784-42d0-9799-29d5c99f3472","name":"Modeling","code":"from torch import nn\\nfrom torch.nn import functional as F  \\n\\nclass Model(nn.Module):\\n    def __init__(self, input_dim):\\n        super(Model, self).__init__()\\n        self.layer1 = nn.Linear(input_dim, 50)\\n        self.layer2 = nn.Linear(50, 50)\\n        self.layer3 = nn.Linear(50, 3)\\n    def forward(self, x):\\n        x = F.relu(self.layer1(x))\\n        x = F.relu(self.layer2(x))\\n        x = F.softmax(self.layer3(x), dim=1)\\n        return x\\n    \\nmodel = Model(4).double()","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","name":"Training","code":"def __pdc_trainer__(  # type: ignore # noqa: C901\\n    is_classification: int,\\n    train_loader,  # DataLoader\\n    valid_loader,  # DataLoader\\n    train_metric_members,  # List[str]\\n    valid_metric_members,  # List[str]\\n    monitoring: str,\\n    early_stopping_mode: str,\\n    model,  # nn.Module\\n    loss_impl,  # nn.Module\\n    optimizer_impl,  # nn.optim\\n    learning_rate: float,\\n    n_epochs: int,\\n):\\n    from collections import defaultdict\\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\\n\\n    import pytorch_lightning as pl\\n    import torch\\n    import torchmetrics\\n    from livelossplot import PlotLosses\\n    from pytorch_lightning.callbacks import EarlyStopping\\n    from pytorch_lightning.loggers import LightningLoggerBase\\n    from pytorch_lightning.utilities.distributed import rank_zero_only\\n    from torch import nn\\n    from torch.optim import Optimizer\\n\\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\\n        \\"\\"\\"Canvas Trainer Logger\\"\\"\\"\\n\\n        def __init__(self) -> None:\\n            super().__init__()\\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\\n            self.live_metric = PlotLosses()\\n\\n        @property\\n        def experiment(self) -> None:\\n            pass\\n\\n        @property\\n        def name(self) -> str:\\n            return \\"CanvasTrainerLogger\\"\\n\\n        @property\\n        def version(self) -> str:\\n            return \\"mvp\\"\\n\\n        @rank_zero_only\\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\\n            pass\\n\\n        @rank_zero_only\\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\\n            del metrics[\\"epoch\\"]\\n\\n            if not metrics.keys():\\n                return\\n\\n            is_valid = list(metrics.keys())[-1][:4] == \\"val_\\"\\n\\n            if is_valid:\\n                self.metric_history[\\"val\\"].append(metrics)\\n            else:\\n                self.metric_history[\\"train\\"].append(metrics)\\n                self.live_metric.update({**self.metric_history[\\"train\\"][-1], **self.metric_history[\\"val\\"][-1]})\\n                self.live_metric.send()\\n\\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\\n        def __init__(  # pylint: disable=too-many-arguments\\n            self,\\n            model: nn.Module,\\n            loss_impl: nn.Module,\\n            optimizer_impl: Optimizer,\\n            learning_rate: float,\\n            metric_members: Dict[str, Any],\\n            is_classification: int,\\n        ) -> None:\\n            super().__init__()\\n            self.model = model\\n\\n            self.loss_func = loss_impl()\\n            self.optimizer_impl = optimizer_impl\\n            self.learning_rate = learning_rate\\n\\n            self.metric_members = metric_members\\n\\n            for mode in [\\"train\\", \\"val\\"]:\\n                auroc_metric_attr = (mode + \\"_\\" if mode != \\"train\\" else \\"\\") + \\"auroc\\"\\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get(\\"AUROC\\"))\\n\\n            self._is_classification = is_classification\\n\\n        # pylint: disable=invalid-name\\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\\n            \\"\\"\\"calculate log metric with metric members\\"\\"\\"\\n            metric_members, prefix = None, \\"\\"\\n            if is_valid:\\n                metric_members = self.metric_members[\\"val\\"]\\n                prefix += \\"val_\\"\\n            else:\\n                metric_members = self.metric_members[\\"train\\"]\\n\\n            for metric_member_str, metric_impl in metric_members.items():\\n                if metric_member_str == \\"AUROC\\":\\n                    getattr(self, prefix + \\"auroc\\")(y_hat.detach(), y.detach())\\n                    try:\\n                        self.log(\\n                            prefix + metric_member_str, getattr(self, prefix + \\"auroc\\"), on_step=False, on_epoch=True\\n                        )\\n                    except ValueError():  # type: ignore\\n                        pass\\n\\n                else:\\n                    metric = metric_impl(y_hat, y)\\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\\n\\n        # pylint: disable=arguments-differ\\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=False)\\n\\n        # pylint: disable=arguments-differ\\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\\n            return self._step_func(batch, is_valid=True)\\n\\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\\n            x, y = batch  # pylint: disable=invalid-name\\n            if self._is_classification:\\n                y = y.long()  # pylint: disable=invalid-name\\n            y_hat = self.model(x)\\n\\n            loss = self.loss_func(y_hat, y)\\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\\n            return loss\\n\\n        def configure_optimizers(self) -> Optimizer:\\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\\n\\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\\n        \\"\\"\\"load metric implementation on torch.nn or torchmetrics with their names\\"\\"\\"\\n        metric_impls = {}\\n        for member_str in members:\\n            if member_str == \\"AUROC\\":\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\\n                    num_classes=num_classes, compute_on_step=False\\n                )\\n\\n            elif member_str in [\\"CrossEntropyLoss\\", \\"MSELoss\\", \\"L1Loss\\"]:\\n                metric_impls[member_str] = getattr(nn, member_str)()\\n\\n            elif member_str in [\\"Accuracy\\", \\"AUROC\\", \\"R2Score\\"]:\\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\\n        return metric_impls\\n\\n    # trainer main\\n    n_classes = None\\n    if is_classification:\\n        labels = torch.cat([y for _, y in valid_loader])\\n        if len(labels.unique()) > 2:\\n            n_classes = len(labels.unique())\\n\\n    metric_members = dict(\\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\\n    )\\n\\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\\n    early_stopping_callback = EarlyStopping(monitor=\\"val_\\" + monitoring, mode=early_stopping_mode)\\n    lit = LitModule(\\n        model=model,\\n        loss_impl=loss_impl,\\n        optimizer_impl=optimizer_impl,\\n        learning_rate=learning_rate,\\n        metric_members=metric_members,\\n        is_classification=is_classification,\\n    )\\n    trainer = pl.Trainer(\\n        max_epochs=n_epochs,\\n        logger=canvas_trainer_logger,\\n        callbacks=[early_stopping_callback],\\n        checkpoint_callback=False,\\n    )\\n    trainer.fit(lit, train_loader, valid_loader)\\n    return (canvas_trainer_logger.metric_history, model, model)\\n\\nimport torch\\nc, b, a = __pdc_trainer__(\\n    is_classification=1,\\n    train_loader=train,\\n    valid_loader=valid,\\n    train_metric_members=[\'CrossEntropyLoss\'],\\n    valid_metric_members=[\'CrossEntropyLoss\'],\\n    monitoring=\'CrossEntropyLoss\',\\n    early_stopping_mode=\'min\',\\n    model=model,\\n    loss_impl=torch.nn.CrossEntropyLoss,\\n    optimizer_impl=torch.optim.Adam,\\n    learning_rate=learning_rate,\\n    n_epochs=n_epochs,\\n)\\n","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}},{"id":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","name":"new component","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"inherit","comments":[]}},{"id":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07","name":"new component_2","code":"import pandas as pd\\ndf = pd.DataFrame([1,2,3])\\ndf","metadata":{"componentType":"CodeCell","headerColor":"none","comments":[]}}],"edges":[{"parent":"ab2d95a2-220f-4f7d-8c1a-ef03b514587e","child":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642"},{"parent":"62535059-9784-42d0-9799-29d5c99f3472","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"ecb7141a-ce5c-4fc3-be3b-f42abe7d3642","child":"1a49b14c-abaf-4f75-b146-e43813e2e4fb"},{"parent":"1a49b14c-abaf-4f75-b146-e43813e2e4fb","child":"84484d20-2bd6-472d-91a1-a9c10d1bb17d"},{"parent":"84484d20-2bd6-472d-91a1-a9c10d1bb17d","child":"9dbcb0cb-255c-4aca-95d0-4aaa1e199b07"}]}\n', cookie='_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20_ga=GA1.1.858313459.1651647659;%20_xsrf=2%7Cd9b93425%7Cb864037f78e720e235051f18f4b2f004%7C1655086118;%20_ga_PQWQV19ZLY=GS1.1.1655106856.5.1.1655107088.0;%20username-localhost-8889=2%7C1:0%7C10:1655115215%7C23:username-localhost-8889%7C44:YjNlMjJkYzI4NGU2NDUyMWJhZDViYzI5MTExYzZhYzQ=%7C317e48d799737ae561637eb2b8d6802ef2b6f757c0ae5d5b93a660e262dae8e7', header='Accept-Encoding=gzip,%20deflate,%20br;Host=localhost:8889;%20Authorization=token%2080add5c51e8e1b74e94b4dc110540ec77ba79bfee95a32f9')
[2022-06-13 19:13:36] mrx-link.MRXLinkMagics.mrxlink_update_dag() DEBUG: graph: {'nodes': [{'id': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'name': 'Read data', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf123', 'metadata': {'componentType': 'CodeCell', 'headerColor': '#00DE62', 'comments': []}}, {'id': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'name': 'Data loader', 'code': 'def __pdc_data_loader__(  # type: ignore\n    input_df: str,\n    ratio: float,\n    batch_size: int,\n    batch_shuffle: bool,\n    tv_shuffle: bool,\n    drop_last: bool,\n    target: list,  # type: ignore\n):\n    """read data from database"""\n    import random\n    from typing import Any, Optional, Tuple\n\n    import pandas as pd\n    import torch\n    from torch.utils.data import DataLoader, Dataset\n\n    class SampleDataset(Dataset):  # pylint: disable=missing-class-docstring\n        def __init__(self, data: pd.DataFrame, target: Optional[pd.DataFrame] = None) -> None:\n            super().__init__()\n            self.data = torch.from_numpy(data.values)\n            if target is not None:\n                self.target = torch.from_numpy(target.values)\n                if target.shape[-1] == 1:\n                    self.target = torch.from_numpy(target.values.squeeze())\n                else:\n                    self.target = torch.from_numpy(target.values)\n            else:\n                self.target = target\n\n        def __len__(self) -> int:\n            return len(self.data)\n\n        def __getitem__(self, idx: int) -> Any:\n            if self.target is not None:\n                return self.data[idx], self.target[idx]\n            return self.data[idx]\n\n    # pylint: disable=missing-function-docstring\n    def split(\n        data: pd.DataFrame, ratio: float, target: Optional[pd.DataFrame] = None, shuffle: bool = False\n    ) -> Tuple[pd.DataFrame, Optional[pd.DataFrame]]:\n\n        data_cnt = int(data.shape[0] * ratio)\n\n        indices = list(data.index)\n        if shuffle:\n            random.shuffle(indices)\n\n        if target is not None:\n            return (\n                (\n                    pd.DataFrame(data, index=indices[:data_cnt]),\n                    pd.DataFrame(target, index=indices[:data_cnt]),\n                ),\n                (\n                    pd.DataFrame(data, index=indices[data_cnt:]),\n                    pd.DataFrame(target, index=indices[data_cnt:]),\n                ),\n            )\n        return (\n            (\n                pd.DataFrame(data, index=indices[:data_cnt]),\n                None,\n            ),\n            (\n                pd.DataFrame(data, index=indices[data_cnt:]),\n                None,\n            ),\n        )\n\n    data: pd.DataFrame = input_df\n    train_loader, valid_loader = None, None\n    if target:\n        data_df = pd.DataFrame(data, columns=[x for x in data.columns if x not in target])\n        target_df = pd.DataFrame(data, columns=target)\n        train, valid = split(data_df, ratio, target_df, tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0], target=train[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0], target=valid[1]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n    else:\n        train, valid = split(data, ratio, shuffle=tv_shuffle)\n        if train[0].shape[0] > 0:\n            train_loader = DataLoader(\n                dataset=SampleDataset(data=train[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n        if valid[0].shape[0] > 0:\n            valid_loader = DataLoader(\n                dataset=SampleDataset(data=valid[0]),\n                batch_size=batch_size,\n                shuffle=batch_shuffle,\n                drop_last=drop_last,\n            )\n\n    return train_loader, valid_loader\n\ntrain, valid = __pdc_data_loader__(\n    input_df=df,\n    ratio=0.8,\n    batch_size=4,\n    batch_shuffle=True,\n    tv_shuffle=True,\n    drop_last=True,\n    target=[\'class\'],\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '62535059-9784-42d0-9799-29d5c99f3472', 'name': 'Modeling', 'code': 'from torch import nn\nfrom torch.nn import functional as F  \n\nclass Model(nn.Module):\n    def __init__(self, input_dim):\n        super(Model, self).__init__()\n        self.layer1 = nn.Linear(input_dim, 50)\n        self.layer2 = nn.Linear(50, 50)\n        self.layer3 = nn.Linear(50, 3)\n    def forward(self, x):\n        x = F.relu(self.layer1(x))\n        x = F.relu(self.layer2(x))\n        x = F.softmax(self.layer3(x), dim=1)\n        return x\n    \nmodel = Model(4).double()', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'name': 'Training', 'code': 'def __pdc_trainer__(  # type: ignore # noqa: C901\n    is_classification: int,\n    train_loader,  # DataLoader\n    valid_loader,  # DataLoader\n    train_metric_members,  # List[str]\n    valid_metric_members,  # List[str]\n    monitoring: str,\n    early_stopping_mode: str,\n    model,  # nn.Module\n    loss_impl,  # nn.Module\n    optimizer_impl,  # nn.optim\n    learning_rate: float,\n    n_epochs: int,\n):\n    from collections import defaultdict\n    from typing import Any, DefaultDict, Dict, List, Optional, Tuple\n\n    import pytorch_lightning as pl\n    import torch\n    import torchmetrics\n    from livelossplot import PlotLosses\n    from pytorch_lightning.callbacks import EarlyStopping\n    from pytorch_lightning.loggers import LightningLoggerBase\n    from pytorch_lightning.utilities.distributed import rank_zero_only\n    from torch import nn\n    from torch.optim import Optimizer\n\n    class CanvasTrainerLightningLogger(LightningLoggerBase):\n        """Canvas Trainer Logger"""\n\n        def __init__(self) -> None:\n            super().__init__()\n            self.metric_history: DefaultDict[str, List[Any]] = defaultdict(list)\n            self.live_metric = PlotLosses()\n\n        @property\n        def experiment(self) -> None:\n            pass\n\n        @property\n        def name(self) -> str:\n            return "CanvasTrainerLogger"\n\n        @property\n        def version(self) -> str:\n            return "mvp"\n\n        @rank_zero_only\n        def log_hyperparams(self, params: Any) -> None:  # pylint: disable=arguments-differ\n            pass\n\n        @rank_zero_only\n        def log_metrics(self, metrics: Dict[str, float], step: Optional[int] = None) -> None:\n            del metrics["epoch"]\n\n            if not metrics.keys():\n                return\n\n            is_valid = list(metrics.keys())[-1][:4] == "val_"\n\n            if is_valid:\n                self.metric_history["val"].append(metrics)\n            else:\n                self.metric_history["train"].append(metrics)\n                self.live_metric.update({**self.metric_history["train"][-1], **self.metric_history["val"][-1]})\n                self.live_metric.send()\n\n    class LitModule(pl.LightningModule):  # pylint: disable=too-many-ancestors, missing-class-docstring\n        def __init__(  # pylint: disable=too-many-arguments\n            self,\n            model: nn.Module,\n            loss_impl: nn.Module,\n            optimizer_impl: Optimizer,\n            learning_rate: float,\n            metric_members: Dict[str, Any],\n            is_classification: int,\n        ) -> None:\n            super().__init__()\n            self.model = model\n\n            self.loss_func = loss_impl()\n            self.optimizer_impl = optimizer_impl\n            self.learning_rate = learning_rate\n\n            self.metric_members = metric_members\n\n            for mode in ["train", "val"]:\n                auroc_metric_attr = (mode + "_" if mode != "train" else "") + "auroc"\n                setattr(self, auroc_metric_attr, self.metric_members[mode].get("AUROC"))\n\n            self._is_classification = is_classification\n\n        # pylint: disable=invalid-name\n        def _calculate_log_metric(self, y_hat: torch.Tensor, y: torch.Tensor, is_valid: bool = False) -> None:\n            """calculate log metric with metric members"""\n            metric_members, prefix = None, ""\n            if is_valid:\n                metric_members = self.metric_members["val"]\n                prefix += "val_"\n            else:\n                metric_members = self.metric_members["train"]\n\n            for metric_member_str, metric_impl in metric_members.items():\n                if metric_member_str == "AUROC":\n                    getattr(self, prefix + "auroc")(y_hat.detach(), y.detach())\n                    try:\n                        self.log(\n                            prefix + metric_member_str, getattr(self, prefix + "auroc"), on_step=False, on_epoch=True\n                        )\n                    except ValueError():  # type: ignore\n                        pass\n\n                else:\n                    metric = metric_impl(y_hat, y)\n                    self.log(prefix + metric_member_str, metric, on_step=False, on_epoch=True)\n\n        # pylint: disable=arguments-differ\n        def training_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=False)\n\n        # pylint: disable=arguments-differ\n        def validation_step(self, batch: Tuple[torch.Tensor, torch.Tensor], _: Any) -> torch.Tensor:\n            return self._step_func(batch, is_valid=True)\n\n        def _step_func(self, batch: Tuple[torch.Tensor, torch.Tensor], is_valid: bool = False) -> torch.Tensor:\n            x, y = batch  # pylint: disable=invalid-name\n            if self._is_classification:\n                y = y.long()  # pylint: disable=invalid-name\n            y_hat = self.model(x)\n\n            loss = self.loss_func(y_hat, y)\n            self._calculate_log_metric(y_hat, y, is_valid=is_valid)\n            return loss\n\n        def configure_optimizers(self) -> Optimizer:\n            return self.optimizer_impl(self.parameters(), lr=self.learning_rate)\n\n    def load_metric_impl(members: List[str], num_classes: Optional[int] = None) -> Optimizer:\n        """load metric implementation on torch.nn or torchmetrics with their names"""\n        metric_impls = {}\n        for member_str in members:\n            if member_str == "AUROC":\n                metric_impls[member_str] = getattr(torchmetrics, member_str)(\n                    num_classes=num_classes, compute_on_step=False\n                )\n\n            elif member_str in ["CrossEntropyLoss", "MSELoss", "L1Loss"]:\n                metric_impls[member_str] = getattr(nn, member_str)()\n\n            elif member_str in ["Accuracy", "AUROC", "R2Score"]:\n                metric_impls[member_str] = getattr(torchmetrics, member_str)()\n        return metric_impls\n\n    # trainer main\n    n_classes = None\n    if is_classification:\n        labels = torch.cat([y for _, y in valid_loader])\n        if len(labels.unique()) > 2:\n            n_classes = len(labels.unique())\n\n    metric_members = dict(\n        train=load_metric_impl(train_metric_members, num_classes=n_classes),\n        val=load_metric_impl(valid_metric_members, num_classes=n_classes),\n    )\n\n    canvas_trainer_logger = CanvasTrainerLightningLogger()\n    early_stopping_callback = EarlyStopping(monitor="val_" + monitoring, mode=early_stopping_mode)\n    lit = LitModule(\n        model=model,\n        loss_impl=loss_impl,\n        optimizer_impl=optimizer_impl,\n        learning_rate=learning_rate,\n        metric_members=metric_members,\n        is_classification=is_classification,\n    )\n    trainer = pl.Trainer(\n        max_epochs=n_epochs,\n        logger=canvas_trainer_logger,\n        callbacks=[early_stopping_callback],\n        checkpoint_callback=False,\n    )\n    trainer.fit(lit, train_loader, valid_loader)\n    return (canvas_trainer_logger.metric_history, model, model)\n\nimport torch\nc, b, a = __pdc_trainer__(\n    is_classification=1,\n    train_loader=train,\n    valid_loader=valid,\n    train_metric_members=[\'CrossEntropyLoss\'],\n    valid_metric_members=[\'CrossEntropyLoss\'],\n    monitoring=\'CrossEntropyLoss\',\n    early_stopping_mode=\'min\',\n    model=model,\n    loss_impl=torch.nn.CrossEntropyLoss,\n    optimizer_impl=torch.optim.Adam,\n    learning_rate=learning_rate,\n    n_epochs=n_epochs,\n)\n', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}, {'id': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'name': 'new component', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'inherit', 'comments': []}}, {'id': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07', 'name': 'new component_2', 'code': 'import pandas as pd\ndf = pd.DataFrame([1,2,3])\ndf', 'metadata': {'componentType': 'CodeCell', 'headerColor': 'none', 'comments': []}}], 'edges': [{'parent': 'ab2d95a2-220f-4f7d-8c1a-ef03b514587e', 'child': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642'}, {'parent': '62535059-9784-42d0-9799-29d5c99f3472', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': 'ecb7141a-ce5c-4fc3-be3b-f42abe7d3642', 'child': '1a49b14c-abaf-4f75-b146-e43813e2e4fb'}, {'parent': '1a49b14c-abaf-4f75-b146-e43813e2e4fb', 'child': '84484d20-2bd6-472d-91a1-a9c10d1bb17d'}, {'parent': '84484d20-2bd6-472d-91a1-a9c10d1bb17d', 'child': '9dbcb0cb-255c-4aca-95d0-4aaa1e199b07'}]}
